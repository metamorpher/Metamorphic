//-----------------------------------------------------------------------
// <copyright company="Metamorphic">
// Copyright (c) Metamorphic. All rights reserved.
// Licensed under the Apache License, Version 2.0 license. See LICENCE.md file in the project root for full license information.
// </copyright>
//-----------------------------------------------------------------------

using System;
using System.Globalization;
using System.Threading;
using System.Threading.Tasks;
using EasyNetQ;
using Metamorphic.Core.Queueing.Properties;
using Nuclei;
using Nuclei.Diagnostics;
using Nuclei.Diagnostics.Logging;

namespace Metamorphic.Core.Queueing
{
    /// <summary>
    /// Defines a processor that dispenses items from a persistent data store.
    /// </summary>
    /// <typeparam name="TItem">The type of item that should be dispensed.</typeparam>
    /// <typeparam name="TId">The type of the ID instance that is used to identity the current {TItem} instance.</typeparam>
    /// <typeparam name="TDataItem">The type of data object that stores all the data of the {TItem} instance.</typeparam>
    internal abstract class PersistentDispenser<TItem, TId, TDataItem> : IDispenseItems<TItem>, IDisposable
        where TItem : class, IHaveIdentity<TId>
        where TId : IIsId<TId>
        where TDataItem : class
    {
        /// <summary>
        /// The object that provides the diagnostics methods for the system.
        /// </summary>
        private readonly SystemDiagnostics _diagnostics;

        /// <summary>
        /// The task scheduler that is used to schedule all tasks generated by the current instance.
        /// </summary>
        private readonly TaskScheduler _scheduler;

        /// <summary>
        /// Indicates if the current object has been disposed.
        /// </summary>
        private volatile bool _isDisposed;

        /// <summary>
        /// The object that references the subscription to the receive event.
        /// </summary>
        private IDisposable _subscription;

        /// <summary>
        /// Initializes a new instance of the <see cref="PersistentDispenser{TItem, TId, TDataItem}"/> class.
        /// </summary>
        /// <param name="bus">The RabbitMQ bus that is used to send and get items from</param>
        /// <param name="storeName">The name of the store from which data is dispensed.</param>
        /// <param name="diagnostics">The object that provides the diagnostics methods for the system.</param>
        /// <param name="scheduler">The task scheduler that is used to schedule all tasks generated by the current instance.</param>
        /// <exception cref="ArgumentNullException">
        ///     Thrown if <paramref name="bus"/> is <see langword="null" />.
        /// </exception>
        /// <exception cref="ArgumentNullException">
        ///     Thrown if <paramref name="storeName"/> is <see langword="null" />.
        /// </exception>
        /// <exception cref="ArgumentException">
        ///     Thrown if <paramref name="storeName"/> is a string that is either empty or only contains whitespace.
        /// </exception>
        /// <exception cref="ArgumentNullException">
        ///     Thrown if <paramref name="diagnostics"/> is <see langword="null" />.
        /// </exception>
        protected PersistentDispenser(IBus bus, string storeName, SystemDiagnostics diagnostics, TaskScheduler scheduler = null)
        {
            if (bus == null)
            {
                throw new ArgumentNullException("bus");
            }

            if (storeName == null)
            {
                throw new ArgumentNullException("storeName");
            }

            if (string.IsNullOrWhiteSpace(storeName))
            {
                throw new ArgumentException(Resources.Exceptions_Messages_ArgumentShouldNotBeAnEmptyString, "storeName");
            }

            if (diagnostics == null)
            {
                throw new ArgumentNullException("diagnostics");
            }

            _subscription = bus.Receive(
                storeName,
                (Func<TDataItem, Task>)ProcessDataItem);
            _diagnostics = diagnostics;
            _scheduler = scheduler ?? TaskScheduler.Default;
        }

        /// <summary>
        /// Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
        /// </summary>
        public void Dispose()
        {
            if (_isDisposed)
            {
                // We've already disposed of everything. Job done.
                return;
            }

            _isDisposed = true;
            if (_subscription != null)
            {
                try
                {
                    _subscription.Dispose();
                }
                catch (ObjectDisposedException)
                {
                    // Just ignore it. If it is disposed then we don't care anymore
                }

                _subscription = null;
            }
        }

        /// <summary>
        /// An event raised when a new item is available in the queue.
        /// </summary>
        public event EventHandler<ItemEventArgs<TItem>> OnItemAvailable;

        private Task ProcessDataItem(TDataItem dataItem)
        {
            return Task.Factory.StartNew(
                () =>
                {
                    if (dataItem == null)
                    {
                        return;
                    }

                    TItem item = null;
                    try
                    {
                        item = FromDataItem(dataItem);
                    }
                    catch (Exception)
                    {
                        _diagnostics.Log(
                            LevelToLog.Warn,
                            string.Format(
                                CultureInfo.InvariantCulture,
                                Resources.Log_Messages_PersistentDispenser_FailedToConvert_WithTypes,
                                dataItem.GetType(),
                                typeof(TItem)));
                        throw;
                    }

                    var itemIdentity = item.IdAsText();
                    try
                    {
                        RaiseOnItemAvailable(item);

                        _diagnostics.Log(
                            LevelToLog.Debug,
                            string.Format(
                                CultureInfo.InvariantCulture,
                                Resources.Log_Messages_PersistentDispenser_Processed_WithId,
                                itemIdentity));
                    }
                    catch (Exception e)
                    {
                        _diagnostics.Log(
                            LevelToLog.Warn,
                            string.Format(
                                CultureInfo.InvariantCulture,
                                Resources.Log_Messages_PersistentDispenser_FailedToProcess_WithIdAndException,
                                itemIdentity,
                                e));
                        throw;
                    }
                },
                CancellationToken.None,
                TaskCreationOptions.None,
                _scheduler);
        }

        private void RaiseOnItemAvailable(TItem item)
        {
            var onEnqueue = OnItemAvailable;
            if (onEnqueue != null)
            {
                onEnqueue(this, new ItemEventArgs<TItem>(item));
            }
        }

        /// <summary>
        /// Converts the data item into an item object.
        /// </summary>
        /// <param name="item">The data item.</param>
        /// <returns>An item object.</returns>
        internal abstract TItem FromDataItem(TDataItem item);
    }
}
